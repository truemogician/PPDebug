# Introduction of PPDebug Website Project
## :zap:Prestatement:zap:
Before the introduction really starts, I need to inform in advance : **The project hasn't been accomplished, some main functionality is not yet implemented, and will be finished in the future. This is a long term project, and I have a plan of getting the website online to help whoever struggling on online judges**  
Though the whole project is not available for experiencing, but the implemented backend APIs are open  
Here's the Postman collection I used for testing: **https://www.getpostman.com/collections/80bd59268b9431edf864**  
And if you are interested in the database structure, feel free to login using the following account  
+ :computer: : rm-bp169vb6t6qq13ksr2o.mysql.rds.aliyuncs.com:3306
+ :boy: : guest
+ :key: : guest19260817  

This account a limited to SELECT operation only.

## :one: Background and Inspiration
Honestly speaking, this idea had been in my mind for quite a long period, which could even date back to my high school time.  
Being an OIer across my high school life, solving problems on online judges was just my daily routine. However, as we may see, most of online judges hold the test dataset invisible, or partly accessible for problem solver. Without input data that crashed your program, it's quite easy to get stuck, struggling to figure out the bug with great effort but resulting in confusion. If you could get a small input dataset, which can be easily analyzed manually and fail your program, you can debug your code base on this input step by step. By monitoring the whole running process, you can detect the key to the bug with ease. And that's exactly what "comparer" is born for. Borrowing a full-score program from your friend, or writing another program with high complexity but guranteed correction, as well as a datamaker to generate random and valid input data, then use batch file to repeatively run datamaker, feeding the data to both programs. When the output of the two differs, you have the dataset you desired.  
This method proves useful and effecient, but writing two extra program could be exhausting. Most of the time, we just want to get the dataset, regardless the datamaker or standard program used. So if a platform could collect them for us to use, it would be great help - and that's exactly what our website designed for.  
After exchanging ideas with other teammates, this plan received highest vote, and then our project started.  
## :two: Work Division
As a modern website, it certainly contains two main part : frontend and backend.  
Generally speaking, backend is about structure and logic, while frontend presents the designing of user interface. Both sides are significant, but backend usually carries more work than frontend. Thus the backend team should be larger than frontend team. However, teamwork is not something linear like evenly dividing the amount of work and distributing them to everyone. Communication effeciency between team members highly influence the whole process of the project. Thus sometimes, more people could even result in slower development pace, and that's why I chose to do backend work all on my own. Backend work is usually closely tied together, while frontend could be divided to different part more easily.  
Thus our finally work division is : I, :construction_worker:***LiuYuqi***, work on the whole backend, :man_with_turban:***LiuYunfan*** designs login and registration pages, :older_man:***ChenChaochen*** writes prolem creation page, :boy:***ZhongYifan*** creates main page and problem page, :man_with_gua_pi_mao:***LiuJijia*** makes the judgement demostration page, :princess:***ZhouYuyang*** and :girl:***ChengJunfei*** are responsible for user profile.
## :three: Framework
I didn't set constraints on frontend, allowing my teammates choose framework according to their own preferrence, resulting in various frameworks in use, including Bootstrap, SemanticUI and so on. Programming language is surely HTML, CSS and Javascript  
As for by backend, I used Express.js based on Node.js, as well as TypeORM for managing database. The whole backend was written in TypeScript, for I'm more familiar with these frameworks and have some experience working with them.
## :four: Website Functionality
As what is mentioned above, the core purpose is to provide a platform for running comparer to get dataset. But if only administrators can create problems and upload standard programs as well as datamakers, the website will be too limited, thus it is designed to be more like a community, where users can upload there own datamakers, standard programs. To evaluate the quality of each code, users using those user-provided programs to compare with their owns can vote them, thus better programs can float up based on voting result. Besides, I borrow the concept of reputation from StackOverflow, which is used to reward users who contribute to the community and manage user privileges. Users with higher reputation can have better performance analysis for each judgement and more options when starting a judgement. Comments are also in my implementation plan. What's more, I also plan to add support for public dataset. Some more features may be added in the future.
## :five: Implementation
To notice that unlike other groups, our backend and frontend are separated completely. My backend program is deployed on my Aliyun remote server behind Nginx as reverse proxy server. I've been working with this server for a while, thus it had already been configured before the project starts with domain name and SSL certificate.  
To work with frontend more effeciently, I wrote an interface instruction before I started to implement, my frontend teammates interact with my APIs according to the interface document. Once some more APIs are suggested, I'll add them on. Implemetation status was also visible on the document.  
Now it's time for implemetation details.  
The first thing I did is database structure design, which cost me almost 2 days. 19 tables was created eventually, with orderly foreign keys linking each other and precisely used data type.  
In order to provide email verification, I first handled sessions and cookies using express.js middlewares. Then I created another midlleware for API authentification, only allowing a few API to be invoked by guest user. When it comes to specific API, I did request verification first, checking out type, pattern and length. If any parameter or payload doesn't meet the requirement, the request will be rejected with detailed http status code and response text - I tried to follow RESTful across the whole project.  
Using SQL language to manipulate database is disturbing and not maintainable, thus I chose to use ORM instead. With TypeORM, communication with database become easy and clear. An entity represents a table, and an instance of an entity is a record of the table. Thus I don't spend much effort on database interaction - all I need is simply create an object and call Repository.save().  
As for implemetation details of each API, please download the main branch and find out by reading the code. Though I didn't write notes for my code, but I'm confident that they could be easily understood. Besides, you can refer to Interface.md - the instruction document I wrote for my frontend teammates.  
The frontend code is a little messy, making it hard to be kepted in a .git folder, thus I pack them up and upload to a standalone repository. Because I change some APIs after the presentation, thus those interaction may not be correct, and thus they are not suitable for previewing. But for assignment purpose, you may download and view it.